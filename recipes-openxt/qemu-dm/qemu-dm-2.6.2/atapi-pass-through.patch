Index: qemu-2.6.2/block/Makefile.objs
===================================================================
--- qemu-2.6.2.orig/block/Makefile.objs
+++ qemu-2.6.2/block/Makefile.objs
@@ -9,6 +9,7 @@ block-obj-y += block-backend.o snapshot.
 block-obj-$(CONFIG_WIN32) += raw-win32.o win32-aio.o
 block-obj-$(CONFIG_POSIX) += raw-posix.o
 block-obj-$(CONFIG_LINUX_AIO) += linux-aio.o
+block-obj-$(CONFIG_ATAPI_PT) += atapi-pt-protocol.o
 block-obj-y += null.o mirror.o io.o
 block-obj-y += throttle-groups.o
 
Index: qemu-2.6.2/block/atapi-pt-protocol.c
===================================================================
--- /dev/null
+++ qemu-2.6.2/block/atapi-pt-protocol.c
@@ -0,0 +1,1403 @@
+/*
+ * ATAPI guest commands translation.
+ *
+ * Copyright (C) 2015 Assured Information Security, Chris Patterson <pattersonc@ainfosec.com>
+ * Copyright (C) 2014 Citrix Systems Ltd
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include "qemu-common.h"
+#include "qemu/module.h"
+#include "block/block_int.h"
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <sys/param.h>
+#include <sys/mman.h>
+#include <fcntl.h>
+#include <linux/cdrom.h>
+#include <linux/fd.h>
+#include <linux/fs.h>
+#include <linux/cdrom.h>
+#include <linux/bsg.h>
+#include <scsi/sg.h>
+#include "hw/xen/xen_backend.h"
+
+
+#ifdef CONFIG_ATAPI_PT_V4V
+#include <libv4v.h>
+#endif
+
+#include <block/atapi_pt_ioctl.h>
+#include <block/atapi_pt_v4v.h>
+
+typedef struct AtapiPtDeviceInfo {
+    /* /dev/bsg/a:b:c:d */
+    char device_path[256];
+
+    char xenstore_domain_base[256];
+    char xenstore_bsgdev_base[256];
+    char xenstore_bsgdevreq_base[256];
+    char xenstore_global_base[256];
+
+    /* a:b:c:d */
+    int device_addr_a;
+    int device_addr_b;
+    int device_addr_c;
+    int device_addr_d;
+
+    /* associated IDEState pointer */
+    void *ide_state;
+
+    /* xenstore-tied flags */
+    int lock_state;
+    int media_state;
+    int have_focus;
+    int autolock;
+    int assigned;
+
+    bool readonly;
+    BlockDriverState *bs;
+} AtapiPtDeviceInfo;
+
+int pt_log_level = 0;
+
+/**
+ * PT_LOG: information to always log (errors & important low-volume events)
+ * @param fmt,... printf style arguments
+ */
+#define PT_LOG(fmt, ...)                                                   \
+    do {                                                                   \
+            fprintf(stdout, "[%s:%s:%d] " fmt,                             \
+                    __FILE__, __FUNCTION__, __LINE__, ##__VA_ARGS__);      \
+    } while (0)
+
+/**
+ * PT_VERBOSE: verbose level
+ * @param fmt,... printf style arguments
+ */
+#define PT_VERBOSE(fmt, ...)                                              \
+    do {                                                                  \
+        if (pt_log_level >= 1)                                            \
+            PT_LOG(fmt, ## __VA_ARGS__);                                  \
+    } while (0)
+
+/**
+ * PT_DEBUG: debug level
+ * @param fmt,... printf style arguments
+ */
+#define PT_DEBUG(fmt, ...)                                               \
+    do {                                                                 \
+        if (pt_log_level >= 2)                                           \
+            PT_LOG(fmt, ## __VA_ARGS__);                                 \
+    } while (0)
+
+typedef struct BDRVPosixPassThroughState {
+    /* device descriptor */
+    int fd;
+    int open_flags;
+
+    /* fcntl lock */
+    int lock_fd;
+    char lock_file_name[1024];
+
+    AtapiPtDeviceInfo dev_info;
+} BDRVPosixPassThroughState;
+
+/**
+ * Notify xenstore about local locking status.
+ * @param[in] info
+ * @param[in] locked: true if locking, false if unlocking
+ */
+static void notify_xs_lock_state(AtapiPtDeviceInfo *info, bool locked)
+{
+    /* write change */
+    if (locked) {
+       xenstore_write_str(info->xenstore_bsgdev_base, "lock", "1");
+    } else {
+       xenstore_rm(info->xenstore_bsgdev_base, "lock");
+    }
+}
+
+/**
+ * Xenstore callback for global media state.
+ * @param[in] opaque: AtapiPtDeviceInfo *
+ */
+static void glob_mediastate_cb(void *opaque)
+{
+    AtapiPtDeviceInfo *info = (AtapiPtDeviceInfo *) opaque;
+
+    if (xenstore_read_int(info->xenstore_global_base, "media",
+                          &info->media_state) != 0) {
+        info->media_state = 0;
+    }
+
+    PT_LOG("media state change detected %s = %d\n",
+            info->device_path, info->media_state);
+
+    /* if autolock is enabled and media is ejected - release lock */
+    if (info->autolock && !info->media_state) {
+        info->assigned = 0;
+        bdrv_ioctl(info->bs, ATAPI_PT_RELEASE_LOCK, NULL);
+    }
+}
+
+/**
+ * Xenstore callback for log level changes.
+ * @param[in] opaque: AtapiPtDeviceInfo *
+ */
+static void loglevel_cb(void *opaque)
+{
+    AtapiPtDeviceInfo *info = (AtapiPtDeviceInfo *) opaque;
+
+    if (xenstore_read_int(info->xenstore_global_base,
+                          "loglevel", &pt_log_level) != 0) {
+        pt_log_level = 0;
+    }
+
+    PT_LOG("loglevel change detected %s = %d\n",
+           info->device_path, pt_log_level);
+}
+
+/**
+ * Xenstore callback for lock changes.
+ * @param[in] opaque: AtapiPtDeviceInfo *
+ */
+static void lock_cb(void *opaque)
+{
+    AtapiPtDeviceInfo *info = (AtapiPtDeviceInfo *) opaque;
+    int lock = 0;
+
+    if (xenstore_read_int(info->xenstore_bsgdev_base, "lock", &lock) != 0) {
+        /* toolstack rm'd the lock key - we are losing the lock */
+        lock = -1;
+    }
+
+    PT_LOG("lock change detected %s = %d\n", info->device_path, lock);
+
+    /* release the lock if we are losing assignment */
+    if (lock == -1) {
+        info->assigned = 0;
+        bdrv_ioctl(info->bs, ATAPI_PT_RELEASE_LOCK, NULL);
+    }
+}
+
+/**
+ * Xenstore callback for autolock changes.
+ * @param[in] opaque: AtapiPtDeviceInfo *
+ */
+static void autolock_cb(void *opaque)
+{
+    AtapiPtDeviceInfo *info = (AtapiPtDeviceInfo *) opaque;
+    int saved_autolock = info->autolock;
+
+    if (xenstore_read_int(info->xenstore_bsgdevreq_base, "autolock",
+                          &info->autolock) != 0) {
+        info->autolock = -1;
+    }
+
+    /* to reduce spurious autolock "changes", log only actual changes */
+    if (saved_autolock != info->autolock) {
+        PT_LOG("autolock change detected %s: %d->%d\n",
+               info->device_path, saved_autolock, info->autolock);
+    }
+}
+
+/**
+ * Xenstore callback for switcher's have_focus changes.
+ * @param[in] opaque: AtapiPtDeviceInfo *
+ */
+static void have_focus_cb(void *opaque)
+{
+    AtapiPtDeviceInfo *info = (AtapiPtDeviceInfo *) opaque;
+
+    if (xenstore_read_int(info->xenstore_domain_base, "switcher/have_focus",
+                          &info->have_focus) != 0) {
+        /* if have_focus key does not exist - we don't have focus */
+        info->have_focus = 0;
+    }
+
+    PT_LOG("focus change detected %s = %d\n",
+            info->device_path, info->have_focus);
+}
+
+/**
+ * Xenstore callback for req-eject changes.
+ * @param[in] opaque: AtapiPtDeviceInfo *
+ */
+static void eject_req_cb(void *opaque)
+{
+    AtapiPtDeviceInfo *info = (AtapiPtDeviceInfo *) opaque;
+    int eject = 0;
+
+    if (xenstore_read_int(info->xenstore_bsgdevreq_base, "req-eject",
+                          &eject) != 0) {
+        /* probably just catching the rm */
+        return;
+    }
+
+    PT_LOG("eject request detected %s = %d\n", info->device_path, eject);
+
+    if (eject) {
+        info->assigned = 0;
+        bdrv_ioctl(info->bs, ATAPI_PT_RELEASE_LOCK, NULL);
+    }
+
+    /* ack receipt of request */
+    xenstore_rm(info->xenstore_bsgdevreq_base, "req-eject");
+}
+
+/**
+ * Xenstore callback for req-assign changes.
+ * @param[in] opaque: AtapiPtDeviceInfo *
+ */
+static void assign_req_cb(void *opaque)
+{
+    AtapiPtDeviceInfo *info = (AtapiPtDeviceInfo *) opaque;
+    int assign = 0;
+
+    if (xenstore_read_int(info->xenstore_bsgdevreq_base, "req-assign",
+                          &assign) != 0) {
+        /* probably just catching the rm */
+        return;
+    }
+
+    PT_LOG("assign_req_cb: assign detected %s = %d\n",
+           info->device_path, assign);
+
+    info->assigned = assign;
+
+    if (assign) {
+        bdrv_ioctl(info->bs, ATAPI_PT_ACQUIRE_LOCK, NULL);
+
+        /* print a warning if we fail to get lock after assignment */
+        if (info->lock_state != ATAPI_PT_LOCK_STATE_LOCKED_BY_ME) {
+            PT_LOG("warning: device assigned but unable to grab lock for %s\n",
+                   info->device_path);
+            PT_LOG("autolock=%d media_state=%d lock_state=%d assigned=%d\n",
+                   info->autolock, info->media_state,
+                   info->lock_state, info->assigned);
+        }
+    } else {
+        bdrv_ioctl(info->bs, ATAPI_PT_RELEASE_LOCK, NULL);
+    }
+
+    /* ack receipt of request */
+    xenstore_rm(info->xenstore_bsgdevreq_base, "req-assign");
+}
+
+
+/**
+ * Checks to see if the device is in a lockable state (or already locked).
+ * @param[in] info
+ */
+static bool is_lockable(AtapiPtDeviceInfo *info)
+{
+    /* it is "lockable" if we currently have the lock */
+    if (info->lock_state == ATAPI_PT_LOCK_STATE_LOCKED_BY_ME) {
+        return true;
+    }
+
+    /* if assigned, assume lockable */
+    if (info->assigned) {
+        return true;
+    }
+
+    /* if autolock is enabled, lockable only if we have focus & cd is present */
+    if (info->autolock && info->have_focus && info->media_state) {
+       return true;
+    }
+
+    return false;
+}
+
+/**
+ * Sets global media state, and releases lock if held and media is not present.
+ * @param[in] info
+ * @param[in] media_present: 1 if media is present, 0 otherwise
+ */
+static void set_global_media_state(AtapiPtDeviceInfo *info, int media_present)
+{
+    info->media_state = media_present;
+
+    PT_LOG("set_global_media_state: %d\n", info->media_state);
+
+    if (xenstore_write_int(info->xenstore_global_base, "media",
+                           info->media_state) != 0) {
+        PT_LOG("failed to set media state\n");
+    }
+}
+
+/**
+ * Set up AtapiPtDeviceInfo structure and init xenstore watches.
+ * @param[in] info
+ * @param[in] filename: device path (format=/dev/bsg/a:b:c:d)
+ * @param[in] bs
+ * @returns true if init OK, otherwise false.
+ */
+static bool atapi_pt_device_info_init(AtapiPtDeviceInfo *info,
+                                      const char *filename,
+                                      BlockDriverState *bs)
+{
+    char path[256];
+
+    memset(info, 0, sizeof(*info));
+
+    info->bs = bs;
+
+    if (sscanf(filename, "/dev/bsg/%d:%d:%d:%d", &info->device_addr_a,
+                                                &info->device_addr_b,
+                                                &info->device_addr_c,
+                                                &info->device_addr_d) != 4) {
+        PT_LOG("error: failed to parse device\n");
+        return false;
+    }
+
+    strncpy(info->device_path, filename, sizeof(info->device_path) - 1);
+    info->device_path[sizeof(info->device_path) - 1] = 0;
+
+    snprintf(info->xenstore_domain_base, sizeof(info->xenstore_domain_base),
+             "/local/domain/%d", xen_domid);
+
+    snprintf(info->xenstore_bsgdev_base, sizeof(info->xenstore_bsgdev_base),
+             "/local/domain/%d/bsgdev/%d_%d_%d_%d",
+             xen_domid,
+             info->device_addr_a,
+             info->device_addr_b,
+             info->device_addr_c,
+             info->device_addr_d);
+
+    snprintf(info->xenstore_bsgdevreq_base,
+             sizeof(info->xenstore_bsgdevreq_base),
+             "/local/domain/%d/bsgdev-req/%d_%d_%d_%d",
+             xen_domid,
+             info->device_addr_a,
+             info->device_addr_b,
+             info->device_addr_c,
+             info->device_addr_d);
+
+    snprintf(info->xenstore_global_base, sizeof(info->xenstore_global_base),
+             "/xenclient/bsgdev/%d_%d_%d_%d",
+             info->device_addr_a,
+             info->device_addr_b,
+             info->device_addr_c,
+             info->device_addr_d);
+
+    /* make sure we can talk to xenstore */
+    xenstore_generic_init();
+
+    /* register xenstore watches */
+    if (xenstore_add_watch(info->xenstore_bsgdevreq_base, "req-eject",
+                            eject_req_cb, info) != 0) {
+        PT_LOG("error: failed to register watch for %p\n", path);
+        return false;
+    }
+
+    if (xenstore_add_watch(info->xenstore_bsgdevreq_base, "req-assign",
+                            assign_req_cb, info) != 0) {
+        PT_LOG("error: failed to register watch for %p\n", path);
+        return false;
+    }
+
+    if (xenstore_add_watch(info->xenstore_bsgdevreq_base, "autolock",
+                            autolock_cb, info) != 0) {
+        PT_LOG("error: failed to register watch for %p\n", path);
+        return false;
+    }
+
+    if (xenstore_add_watch(info->xenstore_global_base, "media",
+                            glob_mediastate_cb, info) != 0) {
+        PT_LOG("error: failed to register watch for %p\n", path);
+        return false;
+    }
+
+    if (xenstore_add_watch(info->xenstore_global_base, "loglevel",
+                            loglevel_cb, info) != 0) {
+        PT_LOG("error: failed to register watch for %p\n", path);
+        return false;
+    }
+
+    if (xenstore_add_watch(info->xenstore_bsgdev_base, "lock",
+                            lock_cb, info) != 0) {
+        PT_LOG("error: failed to register watch for %p\n", path);
+        return false;
+    }
+
+    if (xenstore_add_watch(info->xenstore_domain_base, "switcher/have_focus",
+                            have_focus_cb, info) != 0) {
+        PT_LOG("error: failed to register watch for %p\n", path);
+        return false;
+    }
+
+    if (xenstore_read_int(info->xenstore_bsgdevreq_base, "autolock",
+                          &info->autolock) != 0) {
+        info->autolock = 0;
+    }
+
+    if (xenstore_read_int(info->xenstore_global_base, "media",
+                          &info->media_state) != 0) {
+        info->media_state = 0;
+    }
+
+    if (xenstore_read_int(info->xenstore_domain_base,
+                          "switcher/have_focus", &info->have_focus) != 0) {
+        info->have_focus = 0;
+    }
+
+    if (xenstore_read_int(info->xenstore_bsgdev_base,
+                          "lock", &info->lock_state) != 0) {
+        info->lock_state = 0;
+    }
+
+    /* trigger assign callback in case we have already been issued assignment */
+    assign_req_cb(info);
+    loglevel_cb(info);
+
+    PT_LOG("autolock=%d media_state=%d lock_state=%d assigned=%d\n",
+           info->autolock, info->media_state, info->lock_state, info->assigned);
+
+    return true;
+}
+
+/**
+ * Convert open flags appropriately for pt local device.
+ * @param[in] bdrv_flags: block driver flags from qemu
+ * @param[in] open_flags: device open flags
+ * @returns updated open flags
+ */
+static int pt_local_parse_open_flags(int bdrv_flags, int open_flags)
+{
+    open_flags |= O_BINARY;
+    open_flags &= ~O_ACCMODE;
+    if (bdrv_flags & BDRV_O_RDWR) {
+        open_flags |= O_RDWR;
+    } else {
+        open_flags |= O_RDONLY;
+    }
+
+    /* Use O_DSYNC for write-through caching, no flags for write-back caching,
+     * and O_DIRECT for no caching. */
+    if ((bdrv_flags & BDRV_O_NOCACHE)) {
+        open_flags |= O_DIRECT;
+    }
+
+    return open_flags;
+}
+
+/**
+ * If protocol matches, opens local device.
+ * @param[in] bs
+ * @param[in] filename: device path (e.g. /dev/bsg/a:b:c:d)
+ * @param[in] bdrv_flags: block driver flags from qemu
+ * @param[in] flags: device open flags
+ * @returns 0 if opened successfully, -1 otherwise
+ */
+static int pt_local_open_device(BlockDriverState *bs, const char *filename,
+                       int bdrv_flags, int open_flags)
+{
+    BDRVPosixPassThroughState *s = bs->opaque;
+    int fd;
+
+    PT_LOG("opening %s\n", filename);
+
+    s->open_flags = open_flags;
+    s->open_flags = pt_local_parse_open_flags(bdrv_flags, s->open_flags);
+
+    s->fd = -1;
+    fd = qemu_open(filename, s->open_flags, 0644);
+
+    if (fd < 0) {
+        PT_LOG("failed to open %s (%s)\n", filename, strerror(errno));
+        if (errno == EROFS) {
+            return -EACCES;
+        }
+        return -errno;
+    }
+    s->fd = fd;
+
+    PT_LOG("opened %s (%d)\n", filename, fd);
+
+    return 0;
+}
+
+/**
+ * Close device descriptor and cleanup.
+ * @param[in] bs
+ */
+static void pt_local_close(BlockDriverState * bs)
+{
+    BDRVPosixPassThroughState *s = bs->opaque;
+
+    PT_LOG("closing device %d\n", s->fd);
+
+    if (s->fd >= 0) {
+        qemu_close(s->fd);
+        s->fd = -1;
+    }
+}
+
+/**
+ * Probes device and matches if it looks to be a valid atapi-pt-local.
+ * @param[in] filename: format "atapi-pt-local:/dev/bsg/a:b:c:d"
+ * @returns 0 if invalid, 100 if valid (probe priority)
+ */
+static int pt_local_probe_device(const char *filename)
+{
+    int fd;
+    struct stat st;
+
+    if (strncmp(filename, "atapi-pt-local:", strlen("atapi-pt-local:")) != 0) {
+        PT_DEBUG("not a pt device %s\n", filename);
+        return -1;
+    }
+
+    filename += strlen("atapi-pt-local:");
+
+    PT_DEBUG("probing: %s\n", filename);
+
+    fd = qemu_open(filename, O_RDONLY | O_NONBLOCK);
+
+    if (fd < 0) {
+        PT_LOG("failed to open %s\n", filename);
+        return -1;
+    }
+
+    if (fstat(fd, &st) < 0) {
+        PT_LOG("failed to validate %s - fstat failed\n", filename);
+        qemu_close(fd);
+        return -1;
+    }
+
+    if (S_ISBLK(st.st_mode)) {
+        PT_LOG("failed to validate %s - not a block device\n", filename);
+        qemu_close(fd);
+        return -1;
+    }
+
+    qemu_close(fd);
+    return 100;
+}
+
+/**
+ * If protocol matches, opens local device and lock file.
+ * @param[in] bs
+ * @param[in] filename: format "atapi-pt-local:/dev/bsg/a:b:c:d"
+ * @param[in] flags: device open flags
+ * @returns 0 if opened successfully, -1 otherwise
+ */
+static int pt_local_open(BlockDriverState * bs, const char *filename, int flags)
+{
+    BDRVPosixPassThroughState *pts = bs->opaque;
+
+    if (strncmp(filename, "atapi-pt-local:", strlen("atapi-pt-local:")) != 0) {
+        PT_DEBUG("not a pt device %s\n", filename);
+        return -1;
+    }
+
+    filename += strlen("atapi-pt-local:");
+
+    if (pt_local_open_device(bs, filename, flags, O_NONBLOCK | O_RDWR) != 0) {
+        PT_LOG("failed to open device %s\n", filename);
+        return -1;
+    }
+
+    PT_LOG("init for device=%s\n", filename);
+
+    atapi_pt_device_info_init(&pts->dev_info, filename, bs);
+
+    snprintf(pts->lock_file_name, sizeof(pts->lock_file_name),
+          "/var/lock/xen-atapi-pt-lock-%d_%d_%d_%d",
+          pts->dev_info.device_addr_a,
+          pts->dev_info.device_addr_b,
+          pts->dev_info.device_addr_c,
+          pts->dev_info.device_addr_d);
+
+    pts->lock_fd = open(pts->lock_file_name, O_RDWR | O_CREAT, 0666);
+
+    PT_LOG("opened: %s - readonly=%d\n", filename, bdrv_is_read_only(bs));
+
+    return 0;
+}
+
+/**
+ * Grabs global exclusive lock.
+ * @param[in] pts
+ * @returns 1 if lock held, 0 otherwise
+ */
+static int pt_local_acquire_global_lock(BDRVPosixPassThroughState *pts)
+{
+    struct flock lock = {0};
+
+    if (pts->dev_info.lock_state == ATAPI_PT_LOCK_STATE_LOCKED_BY_ME) {
+        /* already have lock */
+        return 1;
+    }
+
+    if (!is_lockable(&pts->dev_info)) {
+        /* currently not allowed to lock - do not attempt */
+        return 0;
+    }
+
+    lock.l_type = F_WRLCK;
+    lock.l_whence = SEEK_SET;
+    lock.l_start = 0;
+    lock.l_len = 0;
+
+    if (fcntl(pts->lock_fd, F_SETLK, &lock) == 0) {
+        PT_LOG("locked by me: %s\n", pts->dev_info.device_path);
+        pts->dev_info.lock_state = ATAPI_PT_LOCK_STATE_LOCKED_BY_ME;
+        notify_xs_lock_state(&pts->dev_info, 1);
+
+        /* signal that medium changed */
+        atapi_pt_notify_medium_maybe_changed(pts->dev_info.ide_state);
+        return 1;
+    }
+
+    PT_LOG("locked by other: %s\n", pts->dev_info.device_path);
+    pts->dev_info.lock_state = ATAPI_PT_LOCK_STATE_LOCKED_BY_OTHER;
+    notify_xs_lock_state(&pts->dev_info, 0);
+    return 0;
+}
+
+/**
+ * Releases global exclusive lock.
+ * @param[in] pts
+ */
+static void pt_local_release_global_lock(BDRVPosixPassThroughState *pts)
+{
+    struct flock lock = {0};
+
+    if (pts->dev_info.lock_state != ATAPI_PT_LOCK_STATE_LOCKED_BY_ME) {
+        /* we don't have the lock, nothing to do */
+        return;
+    }
+
+    lock.l_type = F_UNLCK;
+    lock.l_whence = SEEK_SET;
+    lock.l_start = 0;
+    lock.l_len = 0;
+
+    fcntl(pts->lock_fd, F_SETLK, &lock);
+
+    pts->dev_info.lock_state = ATAPI_PT_LOCK_STATE_UNLOCKED;
+
+    notify_xs_lock_state(&pts->dev_info, 0);
+
+    /* signal that medium has ejected */
+    atapi_pt_notify_medium_ejected(pts->dev_info.ide_state);
+
+    PT_LOG("released lock: %s\n", pts->dev_info.device_path);
+}
+
+/**
+ * Handles "ioctls" from atapi pt driver for atapi-pt-local devices.
+ * @param[in] bs
+ * @param[in] req: ioctl command from atapi_pt_cmd_t enum
+ * @param[inout] buf: pointer to in/out data
+ * Returns: 0 on success, non-zero on failure.
+ */
+static int pt_local_ioctl(BlockDriverState * bs, unsigned long int req,
+                          void *buf)
+{
+    BDRVPosixPassThroughState *pts = bs->opaque;
+    AtapiPtDeviceInfo *info = &pts->dev_info;
+    int ret = 0;
+
+    switch(req)
+    {
+        case ATAPI_PT_OPEN:
+            PT_DEBUG("ATAPI_PT_OPEN: %s\n", info->device_path);
+            if (!buf) {
+                return -ENOTSUP;
+            }
+            info->ide_state = buf;
+            break;
+        case ATAPI_PT_SET_GLOB_MEDIA_STATE:
+            PT_DEBUG("ATAPI_PT_SET_GLOB_MEDIA_STATE: %s\n", info->device_path);
+            if (!buf) {
+                return -ENOTSUP;
+            }
+            set_global_media_state(info, *(uint32_t *)buf);
+            break;
+        case ATAPI_PT_GET_GLOB_MEDIA_STATE:
+            PT_DEBUG("ATAPI_PT_GET_GLOB_MEDIA_STATE: %s\n", info->device_path);
+            if (!buf) {
+                return -ENOTSUP;
+            }
+            *(uint32_t *)buf = info->media_state;
+            break;
+        case ATAPI_PT_ACQUIRE_LOCK:
+            PT_DEBUG("ATAPI_PT_ACQUIRE_LOCK: %s\n", info->device_path);
+            pt_local_acquire_global_lock(pts);
+            if (buf) {
+                *(uint32_t *)buf = info->lock_state;
+            }
+            break;
+        case ATAPI_PT_RELEASE_LOCK:
+            PT_DEBUG("ATAPI_PT_RELEASE_LOCK: %s\n", info->device_path);
+            pt_local_release_global_lock(pts);
+            break;
+        case ATAPI_PT_SG_IO:
+            PT_DEBUG("ATAPI_PT_SG_IO: %s\n", info->device_path);
+            ret = ioctl(pts->fd, SG_IO, buf);
+            if (ret < 0) {
+                PT_DEBUG("SG_IO ioctl() failed (%s).\n", strerror(errno));
+            } else {
+                ret = 0;
+            }
+            break;
+        case ATAPI_PT_SG_GET_RESERVED_SIZE:
+            PT_DEBUG("ATAPI_PT_SG_GET_RESERVED_SIZE: %s\n", info->device_path);
+            ret = ioctl(pts->fd, SG_GET_RESERVED_SIZE, buf);
+            if (ret < 0) {
+                PT_DEBUG("SG_GET_RESERVED_SIZE ioctl() failed: %s\n", strerror(errno));
+            } else {
+                ret = 0;
+            }
+            break;
+        default:
+            return -ENOTSUP;
+    }
+
+    return ret;
+}
+
+static BlockDriver bdrv_host_pt_local = {
+    .format_name         = "atapi-pt",
+    .protocol_name       = "atapi-pt-local",
+    .instance_size       = sizeof(BDRVPosixPassThroughState),
+    .bdrv_probe_device   = pt_local_probe_device,
+    .bdrv_file_open      = pt_local_open,
+    .bdrv_ioctl          = pt_local_ioctl,
+    .bdrv_close          = pt_local_close,
+};
+
+#ifdef CONFIG_ATAPI_PT_V4V
+
+#define V4V_TYPE 'W'
+#define V4VIOCSETRINGSIZE       _IOW (V4V_TYPE,  1, uint32_t)
+
+#define ATAPI_CDROM_PORT 5000
+#define V4V_ATAPI_PT_RING_SIZE \
+  (V4V_ROUNDUP((((4096)*64) - sizeof(v4v_ring_t)-V4V_ROUNDUP(1))))
+
+#define MAX_V4V_MSG_SIZE (V4V_ATAPI_PT_RING_SIZE)
+
+typedef struct BDRVStubdomPassThroughState {
+    int v4v_fd;
+    v4v_addr_t remote_addr;
+    v4v_addr_t local_addr;
+    uint8_t device_id;
+    AtapiPtDeviceInfo dev_info;
+} BDRVStubdomPassThroughState;
+
+/**
+ * Sends v4v message to atapi-pt-helper.
+ * @param[in] hs
+ * @param[in] buf: message to send
+ * @param[in] size: size of buf
+ * @returns true if message sent successfully, false otherwise.
+ */
+static bool pt_v4v_send_message(BDRVStubdomPassThroughState *pts, void *buf,
+                                size_t size)
+{
+    int ret;
+
+    ret = v4v_sendto(pts->v4v_fd, buf, size, 0, &pts->remote_addr);
+
+    if (ret != size) {
+        PT_LOG("error: v4v_sendto() failed (%s) - %d %d.\n",
+                strerror(errno), ret, (int)size);
+        return false;
+    }
+
+    PT_DEBUG("pt_v4v_send_message: cmd = %d - bytes = %d\n", *(char *)buf, ret);
+
+    return true;
+}
+
+/**
+ * Receive v4v message to atapi-pt-helper.
+ * @param[in] hs
+ * @param[out] buf: message to send
+ * @param[in] size: expected size of message
+ * @returns true if message received successfully, false otherwise.
+ */
+static bool pt_v4v_recv_message(BDRVStubdomPassThroughState *pts, void *buf,
+                                size_t size)
+{
+    int ret;
+
+    ret = v4v_recvfrom(pts->v4v_fd, buf, size, 0, &pts->remote_addr);
+
+    if (ret != size) {
+        PT_LOG("error: v4v_sendto() failed (%s) - %d %d.\n",
+                strerror(errno), ret, (int)size);
+        return false;
+    }
+
+    PT_DEBUG("pt_v4v_recv_message: cmd = %d - bytes = %d\n", *(char *)buf, ret);
+
+    return true;
+}
+
+/**
+ * Close v4v device descriptor.
+ * @param[in] bs
+ */
+static void pt_v4v_close(BlockDriverState* bs)
+{
+    BDRVStubdomPassThroughState* pts = bs->opaque;
+
+    if (pts->v4v_fd == -1) {
+        PT_LOG("v4v connection not initialized.");
+    }
+
+    v4v_close(pts->v4v_fd);
+    pts->v4v_fd = -1;
+}
+
+/**
+ * Open v4v descriptor for atapi-pt-v4v device.
+ * @param[in] pts
+ * @param[in] filename: dom0 device path e.g. /dev/bsg/a:b:c:d
+ * Returns: 0 on success, -1 on failure
+ */
+static int pt_v4v_open_common(BDRVStubdomPassThroughState *pts,
+                              const char *filename)
+{
+    pt_v4vcmd_open_request_t request;
+    pt_v4vcmd_open_response_t response;
+    uint32_t v4v_ring_size = V4V_ATAPI_PT_RING_SIZE;
+
+    PT_DEBUG("opening v4v socket...\n");
+    pts->v4v_fd = v4v_socket(SOCK_DGRAM);
+    if (pts->v4v_fd < 0) {
+        PT_DEBUG("v4v_socket() failed (%s).\n", strerror(errno));
+        return -1;
+    }
+
+    pts->local_addr.port = V4V_PORT_NONE;
+    pts->local_addr.domain = V4V_DOMID_ANY;
+
+    pts->remote_addr.port = ATAPI_CDROM_PORT;
+    pts->remote_addr.domain = 0;
+
+    PT_DEBUG("setting v4v ring size...\n");
+    ioctl(pts->v4v_fd, V4VIOCSETRINGSIZE, &v4v_ring_size);
+
+    PT_DEBUG("bind v4v socket with remote...\n");
+    if (v4v_bind(pts->v4v_fd, &pts->local_addr, 0)) {
+        v4v_close(pts->v4v_fd);
+        pts->v4v_fd = -1;
+        PT_DEBUG("error: v4v_bind() failed (%s).\n", strerror(errno));
+        return -1;
+    }
+
+    PT_DEBUG("sending ATAPI_PTV4V_OPEN...\n");
+
+    request.cmd = ATAPI_PTV4V_OPEN;
+    strncpy(&request.device_path[0], filename, sizeof(request.device_path) - 1);
+    request.device_path[sizeof(request.device_path) - 1] = 0;
+
+    if (!pt_v4v_send_message(pts, &request, sizeof(request))) {
+        PT_LOG("error: pt_v4v_send_message() failed\n");
+        v4v_close(pts->v4v_fd);
+        pts->v4v_fd = -1;
+        return -1;
+    }
+
+    if (!pt_v4v_recv_message(pts, &response, sizeof(response))) {
+        PT_LOG("error: pt_v4v_recv_message failed\n");
+        v4v_close(pts->v4v_fd);
+        pts->v4v_fd = -1;
+        return -1;
+    }
+
+    if (response.cmd != ATAPI_PTV4V_OPEN) {
+        PT_LOG("error: code mismatch - %d\n", response.cmd);
+        v4v_close(pts->v4v_fd);
+        pts->v4v_fd = -1;
+        return -1;
+    }
+
+    pts->device_id = response.device_id;
+    return 0;
+}
+
+/**
+ * If protocol matches, opens v4v passthrough device to atapi-dm-helper.
+ * @param[in] bs
+ * @param[in] filename: format "atapi-pt-v4v:/dev/bsg/a:b:c:d"
+ * @param[in] flags: device open flags
+ * @returns 0 if opened successfully, -1 otherwise
+ */
+static int pt_v4v_open(BlockDriverState *bs, const char *filename, int flags)
+{
+    BDRVStubdomPassThroughState *pts = bs->opaque;
+
+    /* check protocol */
+    if (strncmp(filename, "atapi-pt-v4v:", strlen("atapi-pt-v4v:")) != 0) {
+        PT_DEBUG("not a pt device %s\n", filename);
+        return -1;
+    }
+
+    filename += strlen("atapi-pt-v4v:");
+
+    PT_LOG("opening: %s - readonly=%d\n", filename, bdrv_is_read_only(bs));
+
+    atapi_pt_device_info_init(&pts->dev_info, filename, bs);
+
+    return pt_v4v_open_common(pts, filename);
+}
+
+/**
+ * Probes device and matches if it looks to be a valid atapi-pt-v4v.
+ * @param[in] filename: format "atapi-pt-local:/dev/bsg/a:b:c:d"
+ * @returns 0 if invalid, 100 if valid (probe priority)
+ */
+static int pt_v4v_probe_device(const char *filename)
+{
+    BDRVStubdomPassThroughState pts;
+
+    memset(&pts, 0, sizeof(BDRVStubdomPassThroughState));
+
+    /* check protocol */
+    if (strncmp(filename, "atapi-pt-v4v:", strlen("atapi-pt-v4v:")) != 0) {
+        PT_DEBUG("not a pt device %s\n", filename);
+        return -1;
+    }
+
+    filename += strlen("atapi-pt-v4v:");
+
+    /* try to open v4v device given filename */
+    if (pt_v4v_open_common(&pts, filename) == -1) {
+        PT_DEBUG("cannot open %s\n", filename);
+        return -1;
+    }
+
+    v4v_close(pts.v4v_fd);
+    PT_DEBUG("v4v probe device ok: %s", filename);
+    return 100;
+}
+
+/**
+ * Grabs global exclusive lock.
+ * @param[in] pts
+ * @returns 1 if lock held, 0 otherwise
+ */
+static int pt_v4v_acquire_global_lock(BDRVStubdomPassThroughState *pts)
+{
+    pt_v4vcmd_acquire_lock_request_t request;
+    pt_v4vcmd_acquire_lock_response_t response;
+
+    if (pts->dev_info.lock_state == ATAPI_PT_LOCK_STATE_LOCKED_BY_ME) {
+        /* already have lock */
+        return 1;
+    }
+
+    if (!is_lockable(&pts->dev_info)) {
+        /* currently not allowed to lock - do not attempt */
+        return 0;
+    }
+
+    PT_LOG("sending ATAPI_PTV4V_ACQUIRE_LOCK...\n");
+
+    request.cmd = ATAPI_PTV4V_ACQUIRE_LOCK;
+    request.device_id = pts->device_id;
+
+    if (!pt_v4v_send_message(pts, &request, sizeof(request))) {
+        PT_LOG("error: pt_v4v_send_message() failed\n");
+        v4v_close(pts->v4v_fd);
+        pts->v4v_fd = -1;
+        return 0;
+    }
+
+    if (!pt_v4v_recv_message(pts, &response, sizeof(response))) {
+        PT_LOG("error: pt_v4v_recv_message failed\n");
+        v4v_close(pts->v4v_fd);
+        pts->v4v_fd = -1;
+        return 0;
+    }
+
+    /* validate received packet header */
+    if (response.cmd != ATAPI_PTV4V_ACQUIRE_LOCK) {
+        PT_LOG("error: invalid packet data\n");
+        v4v_close(pts->v4v_fd);
+        pts->v4v_fd = -1;
+        return 0;
+    }
+
+    pts->dev_info.lock_state = response.lock_state;
+
+    if (pts->dev_info.lock_state == ATAPI_PT_LOCK_STATE_LOCKED_BY_ME) {
+        notify_xs_lock_state(&pts->dev_info, 1);
+
+        /* signal that medium is changing */
+        atapi_pt_notify_medium_maybe_changed(pts->dev_info.ide_state);
+        return 1;
+    }
+
+    PT_LOG("warning: failed to grab lock for %s - lock_state = %d\n",
+           pts->dev_info.device_path, pts->dev_info.lock_state);
+
+    notify_xs_lock_state(&pts->dev_info, 0);
+    return 0;
+}
+
+/**
+ * Releases global exclusive lock.
+ * @param[in] pts
+ */
+static void pt_v4v_release_global_lock(BDRVStubdomPassThroughState *pts)
+{
+    pt_v4vcmd_release_lock_request_t request;
+
+    if (pts->dev_info.lock_state != ATAPI_PT_LOCK_STATE_LOCKED_BY_ME) {
+        /* we don't have the lock, nothing to do */
+        return;
+    }
+
+    PT_DEBUG("sending ATAPI_PTV4V_RELEASE_LOCK...\n");
+
+    request.cmd = ATAPI_PTV4V_RELEASE_LOCK;
+    request.device_id = pts->device_id;
+
+    if (!pt_v4v_send_message(pts, &request, sizeof(request))) {
+        PT_LOG("error: pt_v4v_send_message() failed\n");
+        v4v_close(pts->v4v_fd);
+        pts->v4v_fd = -1;
+        return;
+    }
+
+    pts->dev_info.lock_state = ATAPI_PT_LOCK_STATE_UNLOCKED;
+    notify_xs_lock_state(&pts->dev_info, 0);
+
+    /* signal that medium is ejected */
+    atapi_pt_notify_medium_ejected(pts->dev_info.ide_state);
+
+    PT_LOG("released lock: %s\n", pts->dev_info.device_path);
+}
+
+
+
+/**
+ * Handles pass-through ioctls from atapi pt driver for atapi-pt-v4v devices
+ * @param[in] bs
+ * @param[out] size: reserved size response - must not be NULL.
+ * Returns: 0 on success, non-zero on failure.
+ */
+static int pt_v4v_sg_get_reserved_size(BlockDriverState *bs, uint32_t *size)
+{
+    BDRVStubdomPassThroughState *pts = bs->opaque;
+
+    pt_v4vcmd_sg_get_reserved_size_request_t request;
+    pt_v4vcmd_sg_get_reserved_size_response_t response;
+
+    PT_DEBUG("sending ATAPI_PTV4V_SG_GET_RESERVED_SIZE...\n");
+
+    assert(size != NULL);
+
+    *size = 0;
+
+    request.cmd = ATAPI_PTV4V_SG_GET_RESERVED_SIZE;
+    request.device_id = pts->device_id;
+
+    if (!pt_v4v_send_message(pts, &request, sizeof(request))) {
+        PT_LOG("error: pt_v4v_send_message() failed\n");
+        pt_v4v_close(bs);
+        return -1;
+    }
+
+    if (!pt_v4v_recv_message(pts, &response, sizeof(response))) {
+        PT_LOG("error: pt_v4v_recv_message failed\n");
+        pt_v4v_close(bs);
+        return -1;
+    }
+
+    /* validate received packet header */
+    if (response.cmd != ATAPI_PTV4V_SG_GET_RESERVED_SIZE) {
+        PT_LOG("error: invalid packet data\n");
+        pt_v4v_close(bs);
+        return -1;
+    }
+
+    *size = response.size;
+    return 0;
+}
+
+/**
+ * Handles pass-through ioctls from atapi pt driver for atapi-pt-v4v devices
+ * @param[in] bs
+ * @param[in] req: sg ioctl command
+ * @param[inout] buf: pointer to in/out data
+ * Returns: 0 on success, non-zero on failure.
+ */
+static int pt_v4v_sg_ioctl(BlockDriverState *bs, unsigned long int req,
+                           void *buf)
+{
+    BDRVStubdomPassThroughState *pts = bs->opaque;
+
+    struct sg_io_v4 *cmd = (struct sg_io_v4 *)buf;
+    struct request_sense *sense;
+
+    /* sgio_v4 tracks pointers with u64 */
+    uint64_t req_xferp = 0;
+    uint64_t dout_xferp = 0;
+    uint64_t din_xferp = 0;
+    uint32_t din_xfer_len = 0;
+
+    uint8_t buf_out[sizeof(pt_v4vcmd_sg_io_request_t) + cmd->dout_xfer_len];
+    pt_v4vcmd_sg_io_request_t *request = (pt_v4vcmd_sg_io_request_t *)buf_out;
+
+    uint8_t buf_in[sizeof(pt_v4vcmd_sg_io_response_t) + cmd->din_xfer_len];
+    pt_v4vcmd_sg_io_response_t *response = (pt_v4vcmd_sg_io_response_t *)buf_in;
+
+    int len;
+
+    PT_DEBUG("sending ATAPI_PTV4V_SG_IO...\n");
+
+    if (sizeof(buf_out) > MAX_V4V_MSG_SIZE) {
+        PT_LOG("error: dout_data too large - cannot complete command\n");
+        return -1;
+    }
+    memset(buf_out, 0, sizeof(buf_out));
+
+    if (sizeof(buf_in) > MAX_V4V_MSG_SIZE) {
+        PT_LOG("error: din_data too large - cannot complete command\n");
+        return -1;
+    }
+    memset(buf_in, 0, sizeof(buf_in));
+
+    if (pts->v4v_fd == -1) {
+        PT_LOG("error: v4v connection not initialized.");
+        return -1;
+    }
+
+    request->cmd = ATAPI_PTV4V_SG_IO;
+    request->device_id = pts->device_id;
+
+    /* make sure dout_xfer_len will fit in request */
+    if (sizeof(buf_out) < sizeof(request) + cmd->dout_xfer_len) {
+        PT_LOG("error: bad dout_xfer_len %d", cmd->dout_xfer_len);
+        pt_v4v_close(bs);
+        return -1;
+    }
+
+    /* make sure din_xfer_len will fit in response */
+    if (sizeof(buf_in) < sizeof(response) + cmd->din_xfer_len) {
+        PT_LOG("error: bad din_xfer_len %d", cmd->din_xfer_len);
+        pt_v4v_close(bs);
+        return -1;
+    }
+
+    /* populate sgio */
+    memcpy(&request->sgio, cmd, sizeof(struct sg_io_v4));
+
+    /* make sure request data is sized properly */
+    if (cmd->request_len != sizeof(request->request_data)) {
+        PT_LOG("error: bad request_len %d", cmd->request_len);
+        pt_v4v_close(bs);
+        return -1;
+    }
+
+    /* validate outgoing sense ("response") data len */
+    if (cmd->max_response_len != sizeof(response->sense_data)) {
+        PT_LOG("error: invalid max_response_len! %d\n", cmd->max_response_len);
+        return -1;
+    }
+
+    /* copy atapi packet request */
+    memcpy(&request->request_data[0], (void *)(uintptr_t)cmd->request, cmd->request_len);
+
+    if (cmd->dout_xfer_len > 0) {
+        /* this is dout, update request with dout_xfer data */
+        memcpy(&request->dout_data[0], (void *)(uintptr_t)cmd->dout_xferp, cmd->dout_xfer_len);
+        request->dout_data_len = cmd->dout_xfer_len;
+    } else {
+        /* this is din, nothing else to do with request, just copy din state */
+        din_xfer_len = cmd->din_xfer_len;
+        din_xferp = cmd->din_xferp;
+    }
+
+    /* save off pointers */
+    dout_xferp = cmd->dout_xferp;
+    req_xferp = cmd->request;
+    sense = (struct request_sense *)(uintptr_t) cmd->response;
+
+    /* calculate packet len and fire away */
+    len = sizeof(*request) + request->dout_data_len;
+    if (!pt_v4v_send_message(pts, request, len)) {
+        PT_LOG("error: pt_v4v_send_message() failed\n");
+        pt_v4v_close(bs);
+        return -1;
+    }
+
+    /* response coming back should be sizeof reply plus expected din data len */
+    len = sizeof(*response) + din_xfer_len;
+    if (!pt_v4v_recv_message(pts, response, len)) {
+        PT_LOG("error: pt_v4v_recv_message failed\n");
+        pt_v4v_close(bs);
+        return -1;
+    }
+
+    /* validate correct command code */
+    if (response->cmd != ATAPI_PTV4V_SG_IO) {
+        PT_LOG("error: command response bad = %d\n", response->cmd);
+        pt_v4v_close(bs);
+        return -1;
+    }
+
+    /* validate that din_xfer_data_len matches */
+    if (response->din_data_len != din_xfer_len) {
+        PT_LOG("error: mismatch din_xfer_len! 0x%x 0%x\n",
+                response->din_data_len, din_xfer_len);
+        pt_v4v_close(bs);
+        return -1;
+    }
+
+    /* copy sg_io_v4 struct back out as there are some output fields */
+    memcpy(cmd, &response->sgio, sizeof(struct sg_io_v4));
+
+    /* restore sgio pointers */
+    cmd->dout_xferp = dout_xferp;
+    cmd->din_xferp = din_xferp;
+    cmd->response = (uint64_t)(uintptr_t)sense;
+    cmd->request = req_xferp;
+
+    /* validate that din_xfer_data_len matches inside sgio packet */
+    if (cmd->din_xfer_len != din_xfer_len) {
+        PT_LOG("error: mismatch cmd->din_xfer_len! 0x%x 0%x\n",
+                cmd->din_xfer_len, din_xfer_len);
+        pt_v4v_close(bs);
+        return -1;
+    }
+
+    /* validate incoming sense ("response") data len */
+    if (cmd->max_response_len != sizeof(response->sense_data)) {
+        PT_LOG("error: invalid max_response_len! %d\n", cmd->max_response_len);
+        return -1;
+    }
+
+    /* copy sense data back out */
+    memcpy(sense, &response->sense_data, sizeof(*sense));
+
+    if (din_xfer_len > 0) {
+        /* this is a din packet - copy din data back out */
+        memcpy((void *)(uintptr_t)din_xferp, &response->din_data[0],
+               din_xfer_len);
+    }
+
+    return 0;
+}
+
+/**
+ * Handles "ioctls" from atapi pt driver for atapi-pt-v4v devices.
+ * @param[in] bs
+ * @param[in] req: ioctl command from atapi_pt_cmd_t enum
+ * @param[inout] buf: pointer to in/out data
+ * Returns: 0 on success, non-zero on failure.
+ */
+static int pt_v4v_ioctl(BlockDriverState *bs, unsigned long int req, void *buf)
+{
+    BDRVStubdomPassThroughState *pts = bs->opaque;
+    AtapiPtDeviceInfo *info = &pts->dev_info;
+
+    switch(req)
+    {
+        case ATAPI_PT_OPEN:
+            PT_DEBUG("ATAPI_PT_OPEN: %s\n", info->device_path);
+            if (!buf) {
+                return -ENOTSUP;
+            }
+            info->ide_state = buf;
+            break;
+        case ATAPI_PT_SET_GLOB_MEDIA_STATE:
+            PT_DEBUG("ATAPI_PT_SET_GLOB_MEDIA_STATE: %s\n", info->device_path);
+            if (!buf) {
+                return -ENOTSUP;
+            }
+            set_global_media_state(info, *(uint32_t *)buf);
+            break;
+        case ATAPI_PT_GET_GLOB_MEDIA_STATE:
+            PT_DEBUG("ATAPI_PT_GET_GLOB_MEDIA_STATE: %s\n", info->device_path);
+            if (!buf) {
+                return -ENOTSUP;
+            }
+            *(uint32_t *)buf = info->media_state;
+            break;
+        case ATAPI_PT_ACQUIRE_LOCK:
+            PT_DEBUG("ATAPI_PT_ACQUIRE_LOCK: %s\n", info->device_path);
+            pt_v4v_acquire_global_lock(pts);
+            if (buf) {
+                *(uint32_t *)buf = info->lock_state;
+            }
+            break;
+        case ATAPI_PT_RELEASE_LOCK:
+            PT_DEBUG("ATAPI_PT_RELEASE_LOCK: %s\n", info->device_path);
+            pt_v4v_release_global_lock(pts);
+            break;
+        case ATAPI_PT_SG_IO:
+            PT_DEBUG("ATAPI_PT_SG_IO: %s\n", info->device_path);
+            if (pt_v4v_sg_ioctl(bs, SG_IO, buf) < 0) {
+                PT_DEBUG("SG_IO ioctl() failed (%s).\n", strerror(errno));
+                return -1;
+            }
+            break;
+        case ATAPI_PT_SG_GET_RESERVED_SIZE:
+            PT_DEBUG("ATAPI_PT_SG_GET_RESERVED_SIZE: %s\n", info->device_path);
+            if (!buf) {
+                return -ENOTSUP;
+            }
+            if (pt_v4v_sg_get_reserved_size(bs, buf) != 0) {
+                PT_DEBUG("SG_GET_RESERVED_SIZE ioctl() failed: %s\n",
+                         strerror(errno));
+                return -1;
+            }
+            break;
+        default:
+            return -ENOTSUP;
+    }
+
+    return 0;
+}
+
+static BlockDriver bdrv_host_pt_v4v = {
+    .format_name = "atapi-pt",
+    .protocol_name = "atapi-pt-v4v",
+    .instance_size = sizeof(BDRVStubdomPassThroughState),
+    .bdrv_probe_device = pt_v4v_probe_device,
+    .bdrv_file_open = pt_v4v_open,
+    .bdrv_ioctl = pt_v4v_ioctl,
+    .bdrv_close = pt_v4v_close,
+};
+
+#endif //CONFIG_ATAPI_PT_V4V
+
+static void bdrv_pt_init(void)
+{
+    /*
+     * Register all the drivers.  Note that order is important, the driver
+     * registered last will get probed first.
+     */
+#ifdef CONFIG_ATAPI_PT_V4V
+    bdrv_register(&bdrv_host_pt_v4v);
+#endif
+    bdrv_register(&bdrv_host_pt_local);
+}
+
+block_init(bdrv_pt_init);
Index: qemu-2.6.2/blockdev.c
===================================================================
--- qemu-2.6.2.orig/blockdev.c
+++ qemu-2.6.2/blockdev.c
@@ -66,6 +66,9 @@ static const char *const if_name[IF_COUN
     [IF_SD] = "sd",
     [IF_VIRTIO] = "virtio",
     [IF_XEN] = "xen",
+#ifdef CONFIG_ATAPI_PT
+    [IF_ATAPI_PT] = "atapi-pt",
+#endif
 };
 
 static int if_max_devs[IF_COUNT] = {
@@ -849,6 +852,9 @@ DriveInfo *drive_new(QemuOpts *all_opts,
     QemuOpts *legacy_opts;
     DriveMediaType media = MEDIA_DISK;
     BlockInterfaceType type;
+#ifdef CONFIG_ATAPI_PT
+    bool atapi_pt = false;
+#endif
     int cyls, heads, secs, translation;
     int max_devs, bus_id, unit_id, index;
     const char *devaddr;
@@ -985,6 +991,13 @@ DriveInfo *drive_new(QemuOpts *all_opts,
         type = block_default_type;
     }
 
+#ifdef CONFIG_ATAPI_PT
+    if (IF_ATAPI_PT == type) {
+        type = IF_IDE;
+        atapi_pt = true;
+    }
+#endif
+
     /* Geometry */
     cyls  = qemu_opt_get_number(legacy_opts, "cyls", 0);
     heads = qemu_opt_get_number(legacy_opts, "heads", 0);
@@ -1172,11 +1185,19 @@ DriveInfo *drive_new(QemuOpts *all_opts,
     blk_set_legacy_dinfo(blk, dinfo);
 
     switch(type) {
+#ifdef CONFIG_ATAPI_PT
+    case IF_ATAPI_PT:
+#endif
     case IF_IDE:
     case IF_SCSI:
     case IF_XEN:
     case IF_NONE:
         dinfo->media_cd = media == MEDIA_CDROM;
+#ifdef CONFIG_ATAPI_PT
+        if (atapi_pt) {
+            dinfo->atapi_pt = true;
+        }
+#endif
         break;
     default:
         break;
